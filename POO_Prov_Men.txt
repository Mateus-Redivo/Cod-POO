1. Sobre herança e classes abstratas, qual afirmação está CORRETA?

A) Uma classe abstrata pode ter métodos abstratos que devem ser implementados pelas subclasses

B) Uma classe abstrata é usada para garantir que apenas as subclasses 
implementem métodos específicos definidos como abstratos

C) Classes abstratas podem ter construtores e serem instanciadas diretamente

D) Métodos abstratos podem ter implementação parcial na classe abstrata



2. Em um sistema que utiliza polimorfismo, é correto afirmar que:

A) Objetos de diferentes subclasses podem ser tratados através da superclasse, mas apenas métodos da superclasse podem ser chamados

B) O mesmo código funcione para diferentes tipos através do upcasting e 
binding dinâmico, chamando métodos específicos de cada subclasse

C) O binding estático garante que sempre o método da superclasse seja chamado

D) Objetos devem ser convertidos explicitamente (cast) antes de serem armazenados em arrays da superclasse



3. Qual das alternativas representa corretamente sobrecarga (overload)?

A) public void processar(int valor) e 
   public int processar(int valor) - na mesma classe

B) public void processar(double valor) na superclasse e 
   public void processar(double valor) na subclasse

C) public void processar(double valor) e 
   public void processar(double valor, String parametro) - na mesma classe

D) public void processar(String valor) e 
   public void processar(Integer valor) - na mesma classe



4. Sobre modificadores de acesso, qual afirmação está CORRETA?

A) protected permite acesso pela classe, subclasses e classes do mesmo pacote

B) private permite acesso pela própria classe e suas subclasses

C) package-private (sem modificador) permite acesso por qualquer classe, incluindo de outros pacotes

D) protected permite acesso pela classe, subclasses de qualquer pacote e classes do mesmo pacote 





5. Analisando o código de uma subclasse:

@Override
public void executarAcao(double parametro) {
    System.out.println("Executando ação específica da subclasse");
    super.executarAcao(parametro);
}

O uso de super.executarAcao(parametro) serve para:

A) Chamar o método executarAcao() da superclasse, substituindo completamente a implementação da subclasse

B) Acessar o atributo executarAcao da superclasse

C) Chamar o método executarAcao() da subclasse recursivamente

D) Chamar o método executarAcao() da superclasse, executando sua lógica além da específica da subclasse




6. Uma classe abstrata é utilizada quando:

A) Queremos impedir que outras classes herdem desta classe

B) Não faz sentido implementar um comportamento genérico na superclasse, apenas nas subclasses específicas 


C) Queremos forçar que todas as subclasses implementem determinados métodos, mas também queremos fornecer implementações comuns

D) Queremos criar uma classe que só pode ter métodos abstratos



7. No código abaixo, o polimorfismo funciona porque:

SuperClasse[] objetos = {objeto1, objeto2, objeto3, objeto4};
for (SuperClasse obj : objetos) {
    obj.metodoComum();
}

A) O binding estático determina qual método será chamado com base no tipo declarado (SuperClasse)

B) O binding dinâmico garante que o método específico de cada tipo real seja chamado

C) Java automaticamente converte todos os objetos para o tipo SuperClasse em tempo de execução

D) O compilador resolve qual método chamar com base no tipo de referência



8. Sobre construtores e super(), qual afirmação está CORRETA?

A) Se não chamarmos super() explicitamente, Java automaticamente chama super() sem parâmetros

B) super() deve ser chamado explicitamente em todos os construtores de subclasses

C) super() pode ser chamado em qualquer linha do construtor, mas é recomendado ser a primeira

D) Se a superclasse não tiver construtor padrão, super() é opcional na subclasse



9. Qual implementação de uma subclasse está CORRETA?

A) public class SubClasse extends SuperClasse {
     private int atributo;
     public SubClasse(String param1, int param2, int param3) {
         this.atributo = param3;
         super(param1, param2);
     }
     @Override public void metodo() { atributo -= 20; }
   }

B) public class SubClasse extends SuperClasse {
     private int atributo;
     public SubClasse(String param1, int param2, int param3) {
         super(param1, param2); 
         this.atributo = param3;
     }
     @Override public void metodo() { atributo -= 20; }
     public void metodoEspecifico(int valor) { atributo += valor; }
   }

C) public class SubClasse extends SuperClasse {
     private int atributo;
     public SubClasse(String param1, int param2, int param3) {
         super(param1, param2); this.atributo = param3;
     }
     public void metodo() { atributo -= 20; }
   }

D) public class SubClasse extends SuperClasse {
     private int atributo;
     public SubClasse(String param1, int param2, int param3) {
         super(param1, param2); this.atributo = param3;
     }
     @Override public void metodo() { return atributo -= 20; }
   }



10. No código abaixo, quais são os ERROS?

public class SubClasse extends SuperClasse {
    private String atributo;
    public SubClasse(String valor) {
        this.atributo = valor;
    }
    public void metodoCalcular() {
        return atributo.length() * 2;
    }
}

A) Apenas o método metodoCalcular() tem erro de tipo de retorno

B) Apenas falta super() no construtor, o método está correto

C) Falta super() no construtor e método metodoCalcular() deve retornar int

D) Falta super() no construtor e o método deveria ser private